---
layout: new
title:  Map
---

#### HashMap

* 数组 + 链表 + 红黑树(jdk8)

```java
public class HashMap<K, V> {

    int size;
    Node<K, V>[] table;

    static class Node<K, V> {

        final int hash;
        final K key;
        V value;
        Node<K, V> next;

    }

}
```

#### TreeMap

* 红黑树

```java
public class TreeMap<K, V> {

    int size;
    Entry<K, V> root;

    static final class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> left;
        Entry<K, V> right;
        Entry<K, V> parent;
        boolean color = BLACK;
    }

}
```

#### LinkedHashMap

* HashMap + 双向链表

```java
public class LinkedHashMap<K, V> extends HashMap<K, V> {

    Entry<K, V> head;
    Entry<K, V> tail;

    static class Entry<K, V> extends HashMap.Node<K, V> {

        Entry<K, V> before;
        Entry<K, V> after;

    }

}
```

#### ConcurrentSkipListMap

* 跳表 + volatile + CAS

```console
Head nodes          Index nodes
+-+    right        +-+                      +-+
|2|---------------->| |--------------------->| |->null
+-+                 +-+                      +-+
 | down              |                        |
 v                   v                        v
+-+            +-+  +-+       +-+            +-+       +-+
|1|----------->| |->| |------>| |----------->| |------>| |->null
+-+            +-+  +-+       +-+            +-+       +-+
 v              |    |         |              |         |
Nodes  next     v    v         v              v         v
+-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
| |->|A|->|B|->|C|->|D|->|E|->|F|->|G|->|H|->|I|->|J|->|K|->null
+-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
```

```java
public class ConcurrentSkipListMap<K, V> {

    volatile HeadIndex<K, V> head;

    static final class HeadIndex<K, V> extends Index<K, V> {

        final int level;

    }

    static class Index<K, V> {

        final Node<K, V> node;
        final Index<K, V> down;
        volatile Index<K, V> right;

    }

    static final class Node<K, V> {

        final K key;
        volatile Object value;
        volatile Node<K, V> next;

    }
    
    private Node<K, V> findPredecessor(Object key, Comparator<? super K> cmp) {
        for (; ; ) {
            for (Index<K, V> q = head, r = q.right, d; ; ) {
                if (r != null) {
                    Node<K, V> n = r.node;
                    K k = n.key;
                    // r节点待删除, cas替换q的右节点
                    if (n.value == null) {
                        if (!q.unlink(r))
                            break;
                        r = q.right;
                        continue;
                    }
                    if (cpr(cmp, key, k) > 0) {
                        // 继续往右查找
                        q = r;
                        r = r.right;
                        continue;
                    }
                }

                // 方法最终出口
                if ((d = q.down) == null)
                    return q.node;

                // 继续往下查找
                q = d;
                r = d.right;
            }
        }
    }

}
```

#### ConcurrentHashMap

#### WeakHashMap
